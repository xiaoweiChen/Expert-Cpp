\begin{enumerate}
	\item 如果使用得当，宏是强大的工具。然而，以下几个方面限制了宏的使用。(1)你不能调试宏;(2)宏观扩张会导致奇怪的副作用;(3)宏没有命名空间，所以如果你有一个宏与其他地方使用的名字冲突，你会得到你不想要的宏替换，这通常会导致奇怪的错误消息;(4)宏可能会影响你不知道的事情。有关详情，请浏览 https:/​/​stackoverflow.​com/​questions/​14041453 .
	\item 类/函数模板是指一种用来生成模板类/函数的模板。它只是一个模板，而不是一个类/函数，因此编译器不会为它生成任何目标代码。模板类/函数是类/函数模板的一个实例。因为它是一个类/函数，相应的目标代码由编译器生成。
	\item 定义类/函数模板时，在关键字template后面有一个<>符号，其中必须给出一个或多个类型形参。<>内部的类型形参称为模板形参列表。当实例化一个类/函数模板时，所有模板形参都必须替换为它们对应的模板实参，这就是模板实参列表。 \par
	隐式实例化按需发生。但是，当提供库文件(.lib)时，您不知道用户将来将使用哪种类型的参数列表，因此，需要显式实例化所有可能的类型。
	\item 多态性意味着某些东西以不同的形式存在。具体来说，在编程语言中，多态性意味着一些函数、操作或对象在不同的上下文中具有几种不同的行为。在C++中，有两种多态性:动态多态性和静态多态性。动态多态性允许用户确定要在运行时执行的实际函数方法，而静态多态性意味着要调用的实际函数(通常是要运行的实际代码)在编译时是已知的。 \par
	函数重载意味着函数用相同的名称定义，但参数集合不同(不同的签名)。 \par
	函数重写是指子类重写父类中定义的虚方法的能力。 \par
	\item 类型特征是一种用于收集有关类型信息的技术。在它的帮助下，我们可以做出更智能的决策，开发高质量的泛型编程优化算法。类型特征可以通过部分或全部模板特化来实现。
	\item 我们可以在g()中写一条错误语句，然后构建代码。如果一个未使用的函数被实例化，编译器将报告错误，否则它将被成功构建。您可以在以下文件ch4\underline{ }5\underline{ }class\underline{ }template\underline{ }implicit\underline{ }inst\underline{ }v2.h和ch4\underline{ }5\underline{ }class\underline{ }template\underline{ }implicit\underline{ }inst\underline{ }B\underline{ }v2.cpp和ch4\underline{ }q7.cpp中找到示例代码，网址是\\https://github.com/PacktPublishing/Mastering- Cpp-Programming./tree/master/Chapter-4
	\item 这是一个开放练习，不需要标准答案。
\end{enumerate}












